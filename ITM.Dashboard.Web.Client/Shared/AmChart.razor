@* // ITM.Dashboard.Web.Client/Shared/AmChart.razor *@
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div id="@ChartId" style="width: 100%; height: @Height;"></div>

@code {
    [Parameter]
    public string ChartId { get; set; } = $"amchart-{Guid.NewGuid()}";

    [Parameter]
    public string ChartType { get; set; } = "XYChart"; // "XYChart", "PieChart"

    [Parameter]
    public object ChartData { get; set; }

    [Parameter]
    public object ChartConfig { get; set; }

    [Parameter]
    public string Height { get; set; } = "400px";

    [CascadingParameter(Name = "IsDarkMode")]
    private bool IsDarkMode { get; set; }

    // ▼▼▼ [핵심 수정 1/2] 마지막으로 렌더링된 데이터와 설정을 캐시할 변수를 추가합니다. ▼▼▼
    private object _cachedData;
    private object _cachedConfig;
    private bool? _cachedDarkMode;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // ▼▼▼ [핵심 수정 2/2] 데이터, 설정, 다크모드 상태가 실제로 변경되었을 때만 차트를 다시 그리도록 로직을 수정합니다. ▼▼▼
        if (ChartData != null && ChartConfig != null && 
            (firstRender || 
             !object.ReferenceEquals(_cachedData, ChartData) || 
             !object.ReferenceEquals(_cachedConfig, ChartConfig) || 
             _cachedDarkMode != IsDarkMode))
        {
            // JS Interop을 호출하여 차트를 생성하거나 업데이트합니다.
            await JSRuntime.InvokeVoidAsync("AmChartsInterop.createOrUpdateChart", ChartId, ChartType, ChartData, ChartConfig, IsDarkMode);

            // 현재 상태를 캐시하여 다음 렌더링과 비교할 수 있도록 합니다.
            _cachedData = ChartData;
            _cachedConfig = ChartConfig;
            _cachedDarkMode = IsDarkMode;
        }
    }

    // 컴포넌트가 소멸될 때 JS에서 생성한 차트 객체도 함께 제거하여 메모리 누수를 방지합니다.
    public async ValueTask DisposeAsync()
    {
        await JSRuntime.InvokeVoidAsync("AmChartsInterop.disposeChart", ChartId);
    }
}
